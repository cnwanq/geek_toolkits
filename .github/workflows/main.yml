name: Notify Robots
on:
  push: # 所有分支的 push 事件均触发
    branches-ignore: [] # 不排除任何分支
jobs:
  send-notification:
    runs-on: ubuntu-latest
    steps:
      # 1. 检出代码（必须步骤）
      - name: Checkout code
        uses: actions/checkout@v4

      # 2. 设置 Python 环境（用于执行脚本）
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'

      # 3. 安装依赖库（requests用于HTTP请求）
      - name: Install dependencies
        run: pip install requests

      # 4. 发送钉钉通知
      # - name: Notify DingTalk
      #   env:
      #     DINGTALK_WEBHOOK: https://oapi.dingtalk.com/robot/send?access_token=1fa397a9958ca9a2e6859689cc02455e473eaf37fbea98331fed4330e30e594b
      #     DINGTALK_SECRET: SEC47e40a9fdb7116a97088a1047cb8d99ade35ab4d2c30aa18d61e3ff4402c4cf2
      #   run: |
      #     python3 -c "
      #     import requests, json, os, time, hashlib, hmac, base64
          
      #     # 获取提交信息
      #     commit_msg = \"\"\"${{ github.event.head_commit.message }}\"\"\"
      #     author = \"${{ github.actor }}\"
          
      #     # 生成钉钉签名
      #     timestamp = str(int(time.time() * 1000))
      #     secret = os.getenv('DINGTALK_SECRET')
      #     string_to_sign = f'{timestamp}\\n{secret}'
      #     hmac_code = hmac.new(
      #         secret.encode(),
      #         string_to_sign.encode(),
      #         digestmod=hashlib.sha256
      #     ).digest()
      #     sign = base64.b64encode(hmac_code).decode()
          
      #     # 构造消息体
      #     payload = {
      #         'msgtype': 'markdown',
      #         'markdown': {
      #             'title': 'GitHub Commit',
      #             'text': f'**提交者**: {author}\\n\\n**内容**: {commit_msg}'
      #         }
      #     }
          
      #     # 发送请求并调试
      #     webhook = os.getenv('DINGTALK_WEBHOOK')
      #     webhook = f'{webhook}&timestamp={timestamp}&sign={sign}'
      #     response = requests.post(webhook, json=payload)
      #     print('钉钉响应状态码:', response.status_code)
      #     print('钉钉响应内容:', response.text)
      #     "
      # 5. 发送飞书通知
      - name: Notify Feishu
        env:
          TZ: Asia/Shanghai
          FEISHU_WEBHOOK: https://open.feishu.cn/open-apis/bot/v2/hook/ed322339-956c-4c86-8467-7a57755bdfc1
          FEISHU_SIGN: dGtFc615enbudNF1c7ewg
        run: |
          python3 -c '
          import requests, json, os, time, hashlib, hmac, base64, re, sys, urllib.parse, datetime

          def escape_markdown(text):
              # 转义 Markdown 特殊字符
              special_chars = ["*", "_", "#", ">", "|", "`", "~", "[", "]", "(", ")", "!"]
              for char in special_chars:
                  text = text.replace(char, "\\" + char)
              return text

          # 检查环境变量
          webhook_url = os.getenv("FEISHU_WEBHOOK")
          if not webhook_url:
              print("错误: FEISHU_WEBHOOK 环境变量未设置")
              sys.exit(1)

          # 获取并转义提交信息
          commit_msg = """${{ github.event.head_commit.message }}"""
          escaped_msg = escape_markdown(commit_msg)
          
          # 生成飞书签名
          current_time = datetime.datetime.now()
          timestamp = str(int(current_time.timestamp()))
          secret = os.getenv("FEISHU_SIGN", "")
          
          print("调试信息:")
          print("当前时间: " + current_time.strftime("%Y-%m-%d %H:%M:%S"))
          print(f"当前时间戳: {timestamp}")
          print(f"签名密钥长度: {len(secret)}")
          print(f"签名密钥: {secret}")
          
          # 按照飞书官方文档生成签名
          string_to_sign = f"{timestamp}\n{secret}"
          hex_string = string_to_sign.encode("utf-8").hex()
          print(f"\n签名字符串（十六进制）: {hex_string}")
          
          hmac_code = hmac.new(
              secret.encode("utf-8"),
              string_to_sign.encode("utf-8"),
              digestmod=hashlib.sha256
          ).digest()
          sign = base64.b64encode(hmac_code).decode("utf-8")

          # 构造消息体
          payload = {
              "msg_type": "interactive",
              "card": {
                  "elements": [{
                      "tag": "div",
                      "text": {"content": escaped_msg, "tag": "lark_md"}
                  }],
                  "header": {
                      "title": {"content": f"来自 ${{ github.actor }} 的提交", "tag": "plain_text"}
                  }
              }
          }

          try:
              # 将签名和时间戳添加到 URL
              url_parts = list(urllib.parse.urlparse(webhook_url))
              query = dict(urllib.parse.parse_qsl(url_parts[4]))
              query.update({
                  "timestamp": timestamp,
                  "sign": sign
              })
              url_parts[4] = urllib.parse.urlencode(query)
              final_url = urllib.parse.urlunparse(url_parts)

              print(f"\n请求信息:")
              print(f"时间戳: {timestamp}")
              print(f"签名字符串: {repr(string_to_sign)}")  # 使用 repr 显示实际的换行符
              print(f"签名结果: {sign}")
              print(f"完整 URL: {final_url}")
              
              # 验证签名
              print("\n签名验证:")
              print(f"1. 原始字符串: {repr(string_to_sign)}")
              print(f"2. 密钥: {secret}")
              print(f"3. 生成的签名: {sign}")
              
              response = requests.post(final_url, json=payload)
              print(f"\n响应信息:")
              print(f"飞书响应状态码: {response.status_code}")
              print(f"飞书响应内容: {response.text}")
              response.raise_for_status()
          except requests.exceptions.RequestException as e:
              print(f"发送请求时出错: {str(e)}")
              sys.exit(1)
          '
